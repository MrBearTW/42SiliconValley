http://feis.github.io/2015/06/22/Introduction_to_C.html  
https://www.youtube.com/playlist?list=PLY_qIufNHc293YnIjVeEwNDuqGo8y2Emx  

從main開始執行 
“ ”中間夾字串 
\n 換行Ｅnter

%d 十進位的整數
＆ 取址運算

#ch2 資料型別
電腦內部記憶儲存空間而該空間是以位元組byte為單位來組成  
一個位元組byte一般由８個位元bit所構成（實際個數為「實作定義」）  
一個位元bit可以表示０或１兩種值  

|資料型別|名稱|大小|例子|  
|:---:|-|-|-|  
|短整數|short int|2*|32|
|整數|int|4*|32|
|長整數|long int|4*|32|
|字元|chart|1|'3'|
|單精度浮點數|float|4*|3.2|
|倍精度浮點數|double|8*|3.2|
|無|void|?||
＊表示該大小是「實作定義」

變數名稱在使用前，需要先宣告或定義  
讀取為指定值得變數在大部分的情形下是「未定義行為」  
  
數字不能當開頭，大小寫是不一樣的  
  
## 整數型別  
１個位元組可以有２５６種不同組合  
從０～２５６（無號數）  
－１２８～１２７（有號數）
  
２個位元組  
６５５３６  
  
４個位元組  
４２９４９６７２９６種組合  
０～４２９４９６７２９５  
－２１４７４８３６４８～２１４７４８３６４７  

long long int C99後支援  
再更大要用矩陣  
  
## 浮點數  
浮點數用來表示實數的方法福點數用來表示實數的方法  
  
科學記號表示法  
有效數字 ＋ 指數  
  
一樣佔用四個位元組  
整數二進位表示法大概近１０位數  
浮點數可以到將近４０位數  

## printf 

|格式符|輸出格式|十進位123為例|
|:---:|-|-|-|  
|%d,%i|10進位有號整數|123|  
|%u|10進位無號整數|123|
|%o|８進位無號整數|173|
|%x|1６進位無號整數(小寫)|7b|
|%X|1６進位無號整數(大寫)|7B|
||<<浮點數>>|123.45|
|%f|十進位浮點數|123.45|
|%e|科學記號表示法(小寫)|1.234500e+02|
|%E|科學記號表示法(大寫)|1.234500E+02|
//有無（正負）號  

## scanf
scanf("%d",&a);
scanf(要讀入的資料格式，變數位址);
從鍵盤讀入一個十進位整數存放在變數a裡面

|格式符|輸入格式|範例|
|:---:|-|-|
|i|任何格式的整數|123|
|d|十進位有號整數|123|
|u|十進位無號整數|123|
|f|十進位浮點數|123.45|
  
不一樣的整數或浮點數的型別做運算時，癮性轉型成範圍較大的型別  
  
## 字元
字長什麼樣子？  
是那個字？  
給每一種字元一個獨一無二的編號  
將儲存字元資訊的問題變成儲存整數的問題  
  
字元型別是種『整數』型別  

ASCII  
32=空白鍵  
48=0  
49=1  
57=9  
65=A  
90=Z  
97=a  
122=z  

### 字元型別
主要有兩種  
char(佔記憶體１個位元組)  
wchar_t(寬字元)  

### char特色
常見使用ＡＳＣＩＩ編碼  
佔用一個位元組  
是一種『整數』型別  
用一組單引號括著：'A'，'a'，'0'，'\n'  
字元格式符%c  
用雙引號括著的是字串  
做2_5_2.c  
`char ch = 'A';`宣告定義一個叫作的字元變數，並初始化為'A'
`printf("%c\n,ch");`用字元格式印出ch字元變數的內容  

### 對chr型別做運算
### 怎麼選擇要使用的型別

|用途|選擇型別|注意事項|printf|scanf|
|:---:|-|-|-|-|  
|整數(一般情況)|int|不要算到超過九位數|%d|%d|
|浮點數(帶小數或者位數過多)|double|可能跟真實數值有誤差|%f|%lf|
|字元(可讀文字)|char||%c|%c|

# Ch3 運算與表示式
運算元＝資料＝具有型別和值  
暫時物件(具有型別和值)  
  
%求餘數
浮點數不能用％運算取餘數  

### 賦值運算
賦值運算子會將右方的值複製給左方的變數  
運算順序是由右至左

## 怎麼表示是非對錯
只用一個位元就可以表示真假  
1 = true  
0 = false  
  
非零的值為真  
零的值為假  
-1 = T  
0 = F  
'\0' = F = null character = 空字元 = 編號０號的字元  

## 關系運算
結果為『真』的話算出int = 1  
結果為『假』的話算出int = 0  
＝＝ 等於  
！＝ 不等於  
Ｃ語言中比較大小一次只能計算一次
3 > 2 > 1 = F(0)  
  
## 邏輯運算子 
關係運算優先於邏輯運算  
！優先於關係運算

&& 而且  
|| 或者  
！ 非

順序
算數 > 關係 > 邏輯
由左至右
０！(右至左)  
１＊／％  
２＋－  
３> < >= =<  
４== !=  
５＆＆  
６｜｜  
７＝(右至左)  

## 程式流程控制
無條件地執行一次（一般述句）
有條件地執行一次（if述句）
無條件地重複執行（無窮迴圈）
有條件地重複執行（while述句）
計次行的重複執行（for述句）
選擇性地執行一次（switch）
至少執行一次下有條件地重複執行（do-while）

## if
if(表示式){程式片段}  

4.1.5跳到4.2

## if-else
if (表示式) {程式片段一} else {程式片段二}


## while
while(表示式){程式片段}


a += 1  
a = a + 1  

a++  
a = a + 1  

int a =0
int b
b = ++a    // a=1 b=1 a原本的值
b = a++    // a=2 b=1 a+1後的值
a = a++    // 未定義行為

## for

## do-while
do{程式片段}while(表示式);  
當表示式成立時就執行程式片段

## 終止與重複


# Ch5 函式
int f(int x){
    return x+3;
}
回傳值的資料型態 函式名稱（參數的資料型態 參數名稱,...）{
    /*程式碼片段*/
    return 回傳值;
}
  
函式內不能再定義其他函示  
在程式碼的順序中，呼叫函式前要先宣告或定義函式  

int f(int x); 函式宣告（假如mainu寫在比較上面）  


#＃ 變數名稱的可視範圍
在同一組區塊{}裡，同名稱變數只能有一個 
  
### 全域變數
宣告在函示定意外
因為容易造成名稱污染，請避免適用

### 區域變數
宣告在函示定義內  

### 函式參數
int f(int i){
    return(0);
}

## 變數名稱可視範圍scope
要在程式碼中使用某個已經宣告的變數名稱需要同時滿足兩個條件
在程式碼中位於該變數名稱宣告以後
該變數是全域變數 或者 被包含在該變數名稱宣告的區塊{}內  

變數名稱的遮蔽，選擇近的那一個  


##函式遞迴
爬樓梯問題
1 1 2 3 5 8 11



#陣列
是一群有相同資料型態的元素集合的資料型態
在記憶體中，一個陣列會使用一段連續的記憶體空間來存放
  
陣列的變數定義  
元素資料型態 陣列變數名稱[元素個數];  
int var[3];  
  
陣列初始化最少要指定一個值，而未指定的元素會被自動指定為０  
int counter[6]={0};  
初始化時，陣列元素個數值可以省略，會已初始化元素個數取代  
int counter[6]={0,0,0,0,0,0};  
  


# 字串
字串是字元的序列  
字串型別(Char)可用來儲存『一個』字元，但需要處理的文字經常是『一串』字元
Ｃ語言並沒有替字串定義一個新的資料行別  
字串是用字元陣列char[]的形式來儲存
透過在<string.h>內提供各種處理字元陣列的函式來實現對字串的操作行為
  
字串是以'\0'表示節味的字元陣列  
char str[] = {'h','e','l','l','o','\0'};
字元陣列可以用“字串內容”進行初始化，會自動加上'\0'字元
char str[] = "Hello";
可以用％s來直接印出字串



# 指標
## 沒有指標的世界
以前不能處理的問題  
在被呼叫的函式中修改引數值  
直接複製陣列  
直接複製字串  
動態改變陣列長度  

## 在被呼叫的函式中修改引數值
函式呼叫時，引數值會複製一份到被呼叫的函式內作為參數使用。  
在函示內部對參數做任何的變動不會改變到原本的引數值  
  
陣列是無法直接複製的  
無法複製陣列也無法複製字串
字串是用陣列組成的  

# 指標型別
『指標』是一種資料型別，用來儲存『記憶體位置』
一般情況下我們是不需要指標的  

### 增加這個型別為什麼可以解決這些以前不能解決問題？
在被呼叫的函式中修改引數值  
直接複製陣列  
直接複製字串  
動態改變陣列長度  

## 指標變數宣告(type*)
『指標』pointer是Ｃ語言的主要特性，是種儲存『記憶體位址』的資料型別  指標變數語法：
```資料型別 ＊變數名稱;```
表示變數內存放的是一個存放這種『資料型別』值的『記憶體位址』

### & 取址運算子
變數依照資料型別會佔據一定的記憶體空間，我們可以用取址運算子＆去取得變數開頭的記憶體位置  
### * 間接運算子    
利用間接運算子＊從記憶體位址取得開頭位於該位址的變數  
  

int count = 9 ;  
int *countAddr = &count ;  
int result = *countAddr ;
等於  
int count = 9;  
int result = count;(count==*countAddr==*&count)  

|表示式|資料型別|值|
|:---:|-|-|
|count|int|9|
|&count|int*|00xx123456|
|countAddr|int*|00xx123456|
|*countAddr|int|9|
  

## 指標型別與取址和間接運算
指標(type *)：可儲存記憶體位址的型別  
取址運算子(&)：可取得變數的記憶體起始位址 ＆變數  
間接運算子(*)：取得以該記憶體位址起始的變數  ＊記憶體位址  
  
相鄰的＊＆可以抵銷  
  
### 函式呼叫特性  
呼叫函式時，做為引數的變數會被複製一份到函式內成為參數  
在被呼叫的函式內對參數做任何的變動都不會改變到原本的參數  
(對函式來說他只是得到一個int的複製品無法知道該整數『原本』存放的地方或來源)  
### 函式呼叫時複製記憶體位址
在呼叫函式時，可以將變數的『記憶體位址』作為引數傳入函式執行。
此時在函式內部對該參數透過『間接運算子』賦予新的數值時就可以改變原本的變數值  
  
## 該傳『變數』』還是『址』
### 基本原則
可以傳值就傳值  
複製一份比較安全，不怕被偷改，確保函示間乾淨的關係  
用起來比較方便，可以傳一般的常數  
### 例外規則
作為引述的變數在呼叫函式後值會變動的時候(例如數值交換)  
無法直接複製值的時候(例如陣列和字串)  
複製的成本太高的時候(例如較複雜的結構)  
  
## 指標對整數的加減運算
可以透過將陣列元素的位址加減一個整數來求得其他元素地址
&v[0] + 1 == &v[1];  
從v[0]位址往前移動兩個陣列元素後的位址  
  
&v[0] + &v[0]  //編譯會失敗
&v[2] - &v[1]＝＝1  //從v[2]到v[1]的位址距離１個元素


## 陣列型別可轉型為指標
n = &v[0] 
陣列型別可隱性轉型成該陣列第一個元素記憶體位址的指標  
n =v 相當於 n = &v[0]  
  
C語言規定陣列的尾巴多的這一格，位子是存在的


## 指標與下標運算子
下標就是中誇號  
  
## 指標與陣列的關係
指標儲存某種陣列元素位址時的特殊性  
可以透過加減整數算出同陣列其他元素的記憶體位址
a[b]運算等同於*(a+b)
在該陣列中從a開始往後移動b所在的陣列元素  
當指標儲存某陣列第一個元素的記憶體位址後，用起來就跟該陣列沒什麼兩樣  
陣列可以隱性轉型成該陣列第一元素的記憶體位址  

## 指標與遞增遞減運算子

## 指標與字串
char strA[]="test"; 
char strB[]={'t','e','s','t','\0'};

printf(strA);    //O
printf(strB);     //O

printf("test");     //O
printf({'t','e','s','t','\0'});     //X

char *strC="test";      //(?字串字面常數)
char *strD={'t','e','s','t','\0'};      //X

printf((char[]){'t','e','s','t','\0'})      // C99：複合字面常數

## 字串字面常數
char *strB = "test" ;
字串字面常數可隱性轉型成字元指標  
Ｃ語言會自動儲存在一個空間，只能讀不能寫







## 解釋 C語言: 超好懂的指標，初學者請進
https://hellolynn.hpd.io/2017/05/15/c%E8%AA%9E%E8%A8%80-%E8%B6%85%E5%A5%BD%E6%87%82%E7%9A%84%E6%8C%87%E6%A8%99%EF%BC%8C%E5%88%9D%E5%AD%B8%E8%80%85%E8%AB%8B%E9%80%B2%EF%BD%9E/  

